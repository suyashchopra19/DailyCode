'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toHaveStyle = toHaveStyle;

var _css = require('css');

var _jestMatcherUtils = require('jest-matcher-utils');

var _jestDiff = require('jest-diff');

var _jestDiff2 = _interopRequireDefault(_jestDiff);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parseCSS(css) {
  var ast = (0, _css.parse)(`selector { ${css} }`, { silent: true }).stylesheet;
  if (ast.parsingErrors && ast.parsingErrors.length > 0) {
    var _ast$parsingErrors$ = ast.parsingErrors[0],
        reason = _ast$parsingErrors$.reason,
        line = _ast$parsingErrors$.line,
        column = _ast$parsingErrors$.column;

    return {
      parsingError: `Syntax error parsing expected css: ${reason} in ${line}:${column}`
    };
  }
  var parsedRules = ast.rules[0].declarations.filter(function (d) {
    return d.type === 'declaration';
  }).reduce(function (obj, _ref) {
    var property = _ref.property,
        value = _ref.value;
    return Object.assign(obj, { [property]: value });
  }, {});
  return { parsedRules };
}

function isSubset(styles, computedStyle) {
  return Object.entries(styles).every(function (_ref2) {
    var prop = _ref2[0],
        value = _ref2[1];
    return computedStyle.getPropertyValue(prop) === value;
  });
}

function printoutStyles(styles) {
  return Object.keys(styles).sort().map(function (prop) {
    return `${prop}: ${styles[prop]};`;
  }).join('\n').concat('\n'); // ensure multiline for diff
}

// Highlights only style rules that were expected but were not found in the
// received computed styles
function expectedDiff(expected, computedStyles) {
  var received = Array.from(computedStyles).filter(function (prop) {
    return expected[prop];
  }).reduce(function (obj, prop) {
    return Object.assign(obj, { [prop]: computedStyles.getPropertyValue(prop) });
  }, {});
  var diffOutput = (0, _jestDiff2.default)(printoutStyles(expected), printoutStyles(received));
  // Remove the "+ Received" annotation because this is a one-way diff
  return diffOutput.replace(`${_chalk2.default.red('+ Received')}\n`, '');
}

function toHaveStyle(htmlElement, css) {
  var _this = this;

  (0, _utils.checkHtmlElement)(htmlElement, toHaveStyle, this);

  var _parseCSS = parseCSS(css),
      expected = _parseCSS.parsedRules,
      parsingError = _parseCSS.parsingError;

  if (parsingError) {
    return {
      pass: this.isNot, // Fail regardless of the test being positive or negative
      message: function message() {
        return parsingError;
      }
    };
  }
  var received = getComputedStyle(htmlElement);
  return {
    pass: isSubset(expected, received),
    message: function message() {
      var matcher = `${_this.isNot ? '.not' : ''}.toHaveStyle`;
      return [(0, _jestMatcherUtils.matcherHint)(matcher, 'element', ''), expectedDiff(expected, received)].join('\n\n');
    }
  };
}